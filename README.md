# NUAA 人工智能导论 实验: 十五数码问题 A* 求解器

## 实验内容
将八数码问题扩展到 $4 \times 4$ 规模的棋盘上（即十五数码问题），实现给定某个初始布局情况及目标布局情况，设计并实现 A* 算法，找出从初始状态到目标状态所需的最少移动棋子的步骤。

## 什么是A*算法
A* (A-star) 算法是一种经典的启发式搜索算法，用于在图中寻找从给定起点到终点的最短路径。它通过一个评估函数 $f(n) = g(n) + h(n)$ 来确定下一个要探索的节点：
- $g(n)$: 从起点到节点 $n$ 的实际代价（例如，在十五数码问题中，这是已经移动的步数）。
- $h(n)$: 从节点 $n$ 到目标节点的估计代价（启发式函数）。这是一个基于问题特性的估计值。
- $f(n)$: 节点 $n$ 的综合优先级。A* 算法总是优先选择 $f(n)$ 值最小的节点进行扩展。

A* 算法使用一个优先队列（通常是最小堆）来存储待访问的节点（称为 Open Set），并使用一个集合来存储已访问过的节点（称为 Closed Set），以避免重复计算和循环。

## 启发函数设计 (Heuristic Function Design)
对于十五数码问题，一个良好且常用的启发函数是**曼哈顿距离 (Manhattan Distance)**。

**曼哈顿距离**:
对于棋盘上的每一个非空棋子，计算其当前位置到目标位置的水平距离和垂直距离之和。所有棋子的曼哈顿距离总和即为当前状态的 $h(n)$ 值。
例如，如果棋子 '7' 当前在 `(r1, c1)` 位置，其目标位置是 `(r2, c2)`，则该棋子的曼哈顿距离为 `|r1 - r2| + |c1 - c2|`。
空块（通常用0表示）不计入曼哈顿距离。

选择曼哈顿距离是因为：
1.  **计算相对简单**：易于实现和计算。
2.  **信息量较好**：比"错位棋子数"等更简单的启发函数能提供更多关于"离目标有多远"的信息，从而更有效地指导搜索。
3.  **可采纳性 (Admissibility)**：这是启发函数的一个重要性质。

### 启发函数的限制条件
为了保证 A* 算法找到最优解（即最短路径），启发函数 $h(n)$ 必须满足以下条件：

1.  **可采纳性 (Admissible Heuristic)**:
    对于所有的节点 $n$, $h(n)$ 必须小于或等于从节点 $n$ 到目标节点的实际最小代价 $h^*(n)$。即 $h(n) \le h^*(n)$。
    如果启发函数是可采纳的，A* 算法保证找到最优解。
    曼哈顿距离是可采纳的，因为每个棋子至少需要移动其曼哈顿距离那么多的步数才能到达目标位置，并且每次移动只能减少一个棋子的曼哈顿距离最多为1。因此，总的曼哈顿距离不会高估实际到达目标所需的步数。

2.  **一致性 (Consistent Heuristic / Monotonicity)** (可选但推荐):
    对于任意节点 $n$ 和通过动作 $a$ 生成的后继节点 $n'$, $h(n) \le c(n, a, n') + h(n')$，其中 $c(n, a, n')$ 是从 $n$ 到 $n'$ 的实际代价。
    如果启发函数是一致的，那么它也一定是可采纳的。一致性还意味着，当 A* 算法首次扩展一个节点时，就已经找到了通往该节点的最优路径。曼哈顿距离也是一致的。

## Python 代码实现
本实验使用 Python 语言实现 A* 算法来解决十五数码问题。
核心代码位于 `fifteen_puzzle_solver.py` 文件中。

主要组成部分：
- `PuzzleNode` 类: 用于表示棋盘的每一个状态，包含状态本身、父节点、到达此状态的g值（步数）、启发式h值（曼哈顿距离）和f值。
- `solve_15_puzzle` 函数: A* 算法主逻辑，使用优先队列管理待探索的节点。
- `is_solvable_standard` 函数: 用于判断一个给定的初始状态相对于标准目标状态是否可解。十五数码问题并非所有初始状态都有解。
- 启发函数计算: 在 `PuzzleNode` 类中实现曼哈顿距离的计算。

## 实验样例 (Experiment Examples)
我们定义了标准的目标状态：
```
 1  2  3  4
 5  6  7  8
 9 10 11 12
13 14 15  .  ( . 表示空块 0)
```

以下是一些实验用的初始状态样例 (这些样例已在 `fifteen_puzzle_solver.py` 中定义并用于测试)：

**样例1 (简单, 1步可解):**
```
 1  2  3  4
 5  6  7  8
 9 10 11  .
13 14 15 12
```

**样例2 (经验证可解):**
```
 1  2  3  4
 5  6  7  8
 9 10  . 11
13 14 15 12
```

**样例3 (稍复杂可解):**
```
 5  1  2  3
 .  6  7  4
 9 10 11  8
13 14 15 12
```

## 实验样例描述 (Experiment Examples Description)
`fifteen_puzzle_solver.py` 脚本的 `main` 函数中包含了上述样例以及对应的目标状态。
运行脚本后，程序会：
1.  针对每个预设的初始状态，首先使用 `is_solvable_standard` 函数判断其对于标准目标状态是否可解。（注意：十五数码问题的可解性判断依赖于逆序数和空格位置的奇偶性）。
2.  如果可解，则调用 A* 算法 (`solve_15_puzzle` 函数) 进行求解。
3.  输出找到的解决方案的移动步数和算法过程中扩展的节点数。
4.  如果不可解，会提示该状态不可解并跳过求解。

### 如何运行
1.  确保您的环境已安装 Python (建议 Python 3.6+)。
2.  将 `fifteen_puzzle_solver.py` 文件保存在您的本地计算机上。
3.  打开终端或命令行工具，导航到该文件所在的目录。
4.  直接运行 `fifteen_puzzle_solver.py` 脚本：
    ```bash
    python fifteen_puzzle_solver.py
    ```
    脚本会依次运行预设的几个测试样例，并打印每个样例的初始状态、目标状态、是否可解、以及求解结果（步数和扩展节点数）。

### 结果与分析 (预期)
- **求解效率**: A* 算法在曼哈顿距离的指导下，能够有效地找到十五数码问题的最优解（即最少移动步数）。
- **扩展节点数**: 扩展的节点数是衡量搜索效率的一个指标。对于更难的谜题（即距离目标状态更远的初始状态），扩展的节点数会显著增加，计算时间也会相应变长。
- **不可解状态**: 程序能正确识别相对于标准目标不可解的初始状态。如果给定一个初始状态和一个特定的目标状态，它们之间的可解性需要更一般的置换奇偶性分析，但本实验主要针对标准目标进行可解性判断。
- **启发函数的重要性**: 曼哈顿距离是一种良好且可采纳的启发函数。与更简单的启发函数（如"错位的棋子数"）相比，曼哈顿距离通常能更有效地指导搜索，减少不必要的节点扩展，从而更快地找到最优解。

通过运行实验，可以观察到不同初始状态下的求解步数和算法效率，从而加深对 A* 算法及其启发函数作用的理解。